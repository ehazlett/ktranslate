// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kentik/ktranslate/pkg/processors/api/v1/processor.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InfoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoRequest) Reset()         { *m = InfoRequest{} }
func (m *InfoRequest) String() string { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()    {}
func (*InfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_63b0136a090d44f6, []int{0}
}
func (m *InfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoRequest.Merge(m, src)
}
func (m *InfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *InfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InfoRequest proto.InternalMessageInfo

type InfoResponse struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoResponse) Reset()         { *m = InfoResponse{} }
func (m *InfoResponse) String() string { return proto.CompactTextString(m) }
func (*InfoResponse) ProtoMessage()    {}
func (*InfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_63b0136a090d44f6, []int{1}
}
func (m *InfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoResponse.Merge(m, src)
}
func (m *InfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *InfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InfoResponse proto.InternalMessageInfo

func (m *InfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type JCHF struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	DstAs                uint32   `protobuf:"varint,2,opt,name=dst_as,json=dstAs,proto3" json:"dst_as,omitempty"`
	DstGeo               string   `protobuf:"bytes,3,opt,name=dst_geo,json=dstGeo,proto3" json:"dst_geo,omitempty"`
	DstAddr              string   `protobuf:"bytes,4,opt,name=dst_addr,json=dstAddr,proto3" json:"dst_addr,omitempty"`
	SrcAddr              string   `protobuf:"bytes,5,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	L4DstPort            uint32   `protobuf:"varint,6,opt,name=l4_dst_port,json=l4DstPort,proto3" json:"l4_dst_port,omitempty"`
	L4SrcPort            uint32   `protobuf:"varint,7,opt,name=l4_src_port,json=l4SrcPort,proto3" json:"l4_src_port,omitempty"`
	Protocol             string   `protobuf:"bytes,8,opt,name=protocol,proto3" json:"protocol,omitempty"`
	DeviceName           string   `protobuf:"bytes,9,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	SrcAs                uint32   `protobuf:"varint,10,opt,name=src_as,json=srcAs,proto3" json:"src_as,omitempty"`
	SrcGeo               string   `protobuf:"bytes,11,opt,name=src_geo,json=srcGeo,proto3" json:"src_geo,omitempty"`
	InBytes              uint64   `protobuf:"varint,12,opt,name=in_bytes,json=inBytes,proto3" json:"in_bytes,omitempty"`
	InPkts               uint64   `protobuf:"varint,13,opt,name=in_pkts,json=inPkts,proto3" json:"in_pkts,omitempty"`
	OutBytes             uint64   `protobuf:"varint,14,opt,name=out_bytes,json=outBytes,proto3" json:"out_bytes,omitempty"`
	OutPkts              uint64   `protobuf:"varint,15,opt,name=out_pkts,json=outPkts,proto3" json:"out_pkts,omitempty"`
	SrcGeoRegion         string   `protobuf:"bytes,16,opt,name=src_geo_region,json=srcGeoRegion,proto3" json:"src_geo_region,omitempty"`
	DstGeoRegion         string   `protobuf:"bytes,17,opt,name=dst_geo_region,json=dstGeoRegion,proto3" json:"dst_geo_region,omitempty"`
	SrcGeoCity           string   `protobuf:"bytes,18,opt,name=src_geo_city,json=srcGeoCity,proto3" json:"src_geo_city,omitempty"`
	DstGeoCity           string   `protobuf:"bytes,19,opt,name=dst_geo_city,json=dstGeoCity,proto3" json:"dst_geo_city,omitempty"`
	SrcEthMac            string   `protobuf:"bytes,20,opt,name=src_eth_mac,json=srcEthMac,proto3" json:"src_eth_mac,omitempty"`
	DstEthMac            string   `protobuf:"bytes,21,opt,name=dst_eth_mac,json=dstEthMac,proto3" json:"dst_eth_mac,omitempty"`
	InputIntDesc         string   `protobuf:"bytes,22,opt,name=input_int_desc,json=inputIntDesc,proto3" json:"input_int_desc,omitempty"`
	OutputIntDesc        string   `protobuf:"bytes,23,opt,name=output_int_desc,json=outputIntDesc,proto3" json:"output_int_desc,omitempty"`
	InputIntAlias        string   `protobuf:"bytes,24,opt,name=input_int_alias,json=inputIntAlias,proto3" json:"input_int_alias,omitempty"`
	OutputIntAlias       string   `protobuf:"bytes,25,opt,name=output_int_alias,json=outputIntAlias,proto3" json:"output_int_alias,omitempty"`
	InputInterfaceIP     string   `protobuf:"bytes,26,opt,name=input_interface_ip,json=inputInterfaceIp,proto3" json:"input_interface_ip,omitempty"`
	OutputInterfaceIP    string   `protobuf:"bytes,27,opt,name=output_interface_ip,json=outputInterfaceIp,proto3" json:"output_interface_ip,omitempty"`
	EventType            string   `protobuf:"bytes,28,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	VlanIn               uint32   `protobuf:"varint,29,opt,name=vlan_in,json=vlanIn,proto3" json:"vlan_in,omitempty"`
	VlanOut              uint32   `protobuf:"varint,30,opt,name=vlan_out,json=vlanOut,proto3" json:"vlan_out,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JCHF) Reset()         { *m = JCHF{} }
func (m *JCHF) String() string { return proto.CompactTextString(m) }
func (*JCHF) ProtoMessage()    {}
func (*JCHF) Descriptor() ([]byte, []int) {
	return fileDescriptor_63b0136a090d44f6, []int{2}
}
func (m *JCHF) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JCHF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JCHF.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JCHF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JCHF.Merge(m, src)
}
func (m *JCHF) XXX_Size() int {
	return m.Size()
}
func (m *JCHF) XXX_DiscardUnknown() {
	xxx_messageInfo_JCHF.DiscardUnknown(m)
}

var xxx_messageInfo_JCHF proto.InternalMessageInfo

func (m *JCHF) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *JCHF) GetDstAs() uint32 {
	if m != nil {
		return m.DstAs
	}
	return 0
}

func (m *JCHF) GetDstGeo() string {
	if m != nil {
		return m.DstGeo
	}
	return ""
}

func (m *JCHF) GetDstAddr() string {
	if m != nil {
		return m.DstAddr
	}
	return ""
}

func (m *JCHF) GetSrcAddr() string {
	if m != nil {
		return m.SrcAddr
	}
	return ""
}

func (m *JCHF) GetL4DstPort() uint32 {
	if m != nil {
		return m.L4DstPort
	}
	return 0
}

func (m *JCHF) GetL4SrcPort() uint32 {
	if m != nil {
		return m.L4SrcPort
	}
	return 0
}

func (m *JCHF) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *JCHF) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *JCHF) GetSrcAs() uint32 {
	if m != nil {
		return m.SrcAs
	}
	return 0
}

func (m *JCHF) GetSrcGeo() string {
	if m != nil {
		return m.SrcGeo
	}
	return ""
}

func (m *JCHF) GetInBytes() uint64 {
	if m != nil {
		return m.InBytes
	}
	return 0
}

func (m *JCHF) GetInPkts() uint64 {
	if m != nil {
		return m.InPkts
	}
	return 0
}

func (m *JCHF) GetOutBytes() uint64 {
	if m != nil {
		return m.OutBytes
	}
	return 0
}

func (m *JCHF) GetOutPkts() uint64 {
	if m != nil {
		return m.OutPkts
	}
	return 0
}

func (m *JCHF) GetSrcGeoRegion() string {
	if m != nil {
		return m.SrcGeoRegion
	}
	return ""
}

func (m *JCHF) GetDstGeoRegion() string {
	if m != nil {
		return m.DstGeoRegion
	}
	return ""
}

func (m *JCHF) GetSrcGeoCity() string {
	if m != nil {
		return m.SrcGeoCity
	}
	return ""
}

func (m *JCHF) GetDstGeoCity() string {
	if m != nil {
		return m.DstGeoCity
	}
	return ""
}

func (m *JCHF) GetSrcEthMac() string {
	if m != nil {
		return m.SrcEthMac
	}
	return ""
}

func (m *JCHF) GetDstEthMac() string {
	if m != nil {
		return m.DstEthMac
	}
	return ""
}

func (m *JCHF) GetInputIntDesc() string {
	if m != nil {
		return m.InputIntDesc
	}
	return ""
}

func (m *JCHF) GetOutputIntDesc() string {
	if m != nil {
		return m.OutputIntDesc
	}
	return ""
}

func (m *JCHF) GetInputIntAlias() string {
	if m != nil {
		return m.InputIntAlias
	}
	return ""
}

func (m *JCHF) GetOutputIntAlias() string {
	if m != nil {
		return m.OutputIntAlias
	}
	return ""
}

func (m *JCHF) GetInputInterfaceIP() string {
	if m != nil {
		return m.InputInterfaceIP
	}
	return ""
}

func (m *JCHF) GetOutputInterfaceIP() string {
	if m != nil {
		return m.OutputInterfaceIP
	}
	return ""
}

func (m *JCHF) GetEventType() string {
	if m != nil {
		return m.EventType
	}
	return ""
}

func (m *JCHF) GetVlanIn() uint32 {
	if m != nil {
		return m.VlanIn
	}
	return 0
}

func (m *JCHF) GetVlanOut() uint32 {
	if m != nil {
		return m.VlanOut
	}
	return 0
}

type ProcessRequest struct {
	JCHF                 *JCHF    `protobuf:"bytes,1,opt,name=jchf,proto3" json:"jchf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessRequest) Reset()         { *m = ProcessRequest{} }
func (m *ProcessRequest) String() string { return proto.CompactTextString(m) }
func (*ProcessRequest) ProtoMessage()    {}
func (*ProcessRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_63b0136a090d44f6, []int{3}
}
func (m *ProcessRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessRequest.Merge(m, src)
}
func (m *ProcessRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProcessRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessRequest proto.InternalMessageInfo

func (m *ProcessRequest) GetJCHF() *JCHF {
	if m != nil {
		return m.JCHF
	}
	return nil
}

type ProcessResponse struct {
	Annotations          map[string]string `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ProcessResponse) Reset()         { *m = ProcessResponse{} }
func (m *ProcessResponse) String() string { return proto.CompactTextString(m) }
func (*ProcessResponse) ProtoMessage()    {}
func (*ProcessResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_63b0136a090d44f6, []int{4}
}
func (m *ProcessResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessResponse.Merge(m, src)
}
func (m *ProcessResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProcessResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessResponse proto.InternalMessageInfo

func (m *ProcessResponse) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func init() {
	proto.RegisterType((*InfoRequest)(nil), "com.kentiklabs.ktranslate.processors.api.v1.InfoRequest")
	proto.RegisterType((*InfoResponse)(nil), "com.kentiklabs.ktranslate.processors.api.v1.InfoResponse")
	proto.RegisterType((*JCHF)(nil), "com.kentiklabs.ktranslate.processors.api.v1.JCHF")
	proto.RegisterType((*ProcessRequest)(nil), "com.kentiklabs.ktranslate.processors.api.v1.ProcessRequest")
	proto.RegisterType((*ProcessResponse)(nil), "com.kentiklabs.ktranslate.processors.api.v1.ProcessResponse")
	proto.RegisterMapType((map[string]string)(nil), "com.kentiklabs.ktranslate.processors.api.v1.ProcessResponse.AnnotationsEntry")
}

func init() {
	proto.RegisterFile("github.com/kentik/ktranslate/pkg/processors/api/v1/processor.proto", fileDescriptor_63b0136a090d44f6)
}

var fileDescriptor_63b0136a090d44f6 = []byte{
	// 908 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcf, 0x6e, 0x22, 0x47,
	0x13, 0xd7, 0xd8, 0x18, 0x43, 0x61, 0x63, 0xdc, 0xeb, 0xfd, 0xb6, 0x8d, 0x77, 0x01, 0xf1, 0xad,
	0x22, 0x4b, 0x91, 0x06, 0xd9, 0xd9, 0x48, 0x9b, 0xec, 0x2a, 0x92, 0xb1, 0x9d, 0x0d, 0x91, 0x36,
	0x46, 0xb3, 0x39, 0xe5, 0x32, 0x1a, 0x86, 0x36, 0xee, 0x00, 0xdd, 0x93, 0xe9, 0x1a, 0x24, 0x94,
	0x6b, 0xee, 0x39, 0xe4, 0x8d, 0x72, 0xca, 0x31, 0x4f, 0x80, 0x22, 0x9e, 0x24, 0xea, 0xea, 0x01,
	0xbc, 0xbe, 0x79, 0x73, 0x72, 0x57, 0xfd, 0xfe, 0x54, 0x75, 0x4d, 0xbb, 0x80, 0xee, 0x48, 0xe2,
	0x5d, 0x36, 0xf0, 0x63, 0x3d, 0xed, 0x8c, 0x85, 0x42, 0x39, 0xee, 0x8c, 0x31, 0x8d, 0x94, 0x99,
	0x44, 0x28, 0x3a, 0xc9, 0x78, 0xd4, 0x49, 0x52, 0x1d, 0x0b, 0x63, 0x74, 0x6a, 0x3a, 0x51, 0x22,
	0x3b, 0xb3, 0xb3, 0x4d, 0xc6, 0x4f, 0x52, 0x8d, 0x9a, 0x7d, 0x1e, 0xeb, 0xa9, 0xef, 0xc4, 0x93,
	0x68, 0x60, 0xfc, 0x8d, 0x81, 0xbf, 0x11, 0xfb, 0x51, 0x22, 0xfd, 0xd9, 0x59, 0xfd, 0x68, 0xa4,
	0x47, 0x9a, 0x74, 0x1d, 0x7b, 0x72, 0x16, 0xf5, 0x93, 0x91, 0xd6, 0xa3, 0x89, 0xe8, 0x50, 0x34,
	0xc8, 0x6e, 0x3b, 0x62, 0x9a, 0xe0, 0x3c, 0x07, 0x9b, 0x0f, 0x41, 0x94, 0x53, 0x61, 0x30, 0x9a,
	0x26, 0x8e, 0xd0, 0xde, 0x87, 0x4a, 0x4f, 0xdd, 0xea, 0x40, 0xfc, 0x92, 0x09, 0x83, 0xed, 0xb7,
	0xb0, 0xe7, 0x42, 0x93, 0x68, 0x65, 0x04, 0x63, 0x50, 0x50, 0xd1, 0x54, 0x70, 0xaf, 0xe5, 0x9d,
	0x96, 0x03, 0x3a, 0x33, 0x0e, 0xbb, 0x33, 0x91, 0x1a, 0xa9, 0x15, 0xdf, 0xa2, 0xf4, 0x2a, 0x6c,
	0xff, 0x51, 0x82, 0xc2, 0xf7, 0x97, 0xdf, 0x7d, 0xcb, 0x9e, 0x43, 0x79, 0x5d, 0x88, 0xb4, 0xdb,
	0xc1, 0x26, 0xc1, 0x5a, 0x50, 0x1c, 0x1a, 0x0c, 0x23, 0x43, 0xfa, 0xfd, 0x6e, 0x79, 0xb9, 0x68,
	0xee, 0x5c, 0x19, 0xbc, 0x30, 0xc1, 0xce, 0xd0, 0xfe, 0x61, 0xff, 0x87, 0x5d, 0xcb, 0x18, 0x09,
	0xcd, 0xb7, 0x6d, 0x89, 0x2e, 0x2c, 0x17, 0xcd, 0xe2, 0x95, 0xc1, 0x77, 0x42, 0x07, 0x56, 0xfc,
	0x4e, 0x68, 0x76, 0x0c, 0x25, 0xb2, 0x19, 0x0e, 0x53, 0x5e, 0x70, 0x8d, 0x58, 0xf5, 0x70, 0x98,
	0x5a, 0xc8, 0xa4, 0xb1, 0x83, 0x76, 0x1c, 0x64, 0xd2, 0x98, 0xa0, 0x06, 0x54, 0x26, 0xaf, 0x42,
	0x2b, 0x4c, 0x74, 0x8a, 0xbc, 0x68, 0x3b, 0x08, 0xca, 0x93, 0x57, 0x57, 0x06, 0xfb, 0x3a, 0xc5,
	0x1c, 0xb7, 0x6a, 0xc2, 0x77, 0x57, 0xf8, 0x87, 0x34, 0x26, 0xbc, 0x0e, 0x25, 0x9a, 0x5c, 0xac,
	0x27, 0xbc, 0x44, 0xd6, 0xeb, 0x98, 0x35, 0xa1, 0x32, 0x14, 0x33, 0x19, 0x8b, 0x90, 0x86, 0x56,
	0x26, 0x18, 0x5c, 0xea, 0x07, 0x3b, 0xba, 0x16, 0x14, 0xa9, 0x2f, 0xc3, 0x61, 0x73, 0xf3, 0x0f,
	0x69, 0x6c, 0x6f, 0x6e, 0x1b, 0x34, 0xec, 0x19, 0xd8, 0x4e, 0xe9, 0xe6, 0x15, 0x92, 0x5b, 0x41,
	0x7e, 0x5b, 0xa9, 0xc2, 0xc1, 0x1c, 0x85, 0xe1, 0x7b, 0x2d, 0xef, 0xb4, 0x10, 0xec, 0x4a, 0xd5,
	0xb5, 0xa1, 0xd5, 0x48, 0x15, 0x26, 0x63, 0x34, 0x7c, 0x9f, 0x90, 0xa2, 0x54, 0xfd, 0x31, 0x1a,
	0x76, 0x02, 0x65, 0x9d, 0x61, 0x2e, 0xaa, 0x12, 0x54, 0xd2, 0x19, 0x3a, 0xd5, 0x31, 0xd8, 0xb3,
	0x93, 0x1d, 0x38, 0x43, 0x9d, 0x21, 0xe9, 0x5e, 0x42, 0x35, 0x6f, 0x22, 0x4c, 0xc5, 0xc8, 0x7e,
	0xe8, 0x1a, 0xf5, 0xb2, 0xe7, 0x7a, 0x09, 0x28, 0x67, 0x59, 0xf9, 0x47, 0x5a, 0xb1, 0x0e, 0x1d,
	0xcb, 0x7d, 0x9f, 0x9c, 0xd5, 0x82, 0xbd, 0x95, 0x57, 0x2c, 0x71, 0xce, 0x99, 0x1b, 0x8a, 0x73,
	0xba, 0x94, 0x38, 0xb7, 0x8c, 0x95, 0x0f, 0x31, 0x9e, 0xe4, 0x63, 0x23, 0x17, 0x62, 0x34, 0xa0,
	0x62, 0x3d, 0x04, 0xde, 0x85, 0xd3, 0x28, 0xe6, 0x47, 0x44, 0x28, 0x9b, 0x34, 0xbe, 0xc6, 0xbb,
	0xf7, 0x51, 0x6c, 0x71, 0xeb, 0xb0, 0xc2, 0x9f, 0x3a, 0x7c, 0x68, 0x30, 0xc7, 0x5f, 0x42, 0x55,
	0xaa, 0x24, 0xc3, 0x50, 0x2a, 0x0c, 0x87, 0xc2, 0xc4, 0xfc, 0x7f, 0xae, 0x53, 0xca, 0xf6, 0x14,
	0x5e, 0x09, 0x13, 0xb3, 0xcf, 0xe0, 0x40, 0x67, 0xf8, 0x11, 0xed, 0x19, 0xd1, 0xf6, 0x5d, 0xfa,
	0x1e, 0x6f, 0xe3, 0x16, 0x4d, 0x64, 0x64, 0x38, 0x77, 0xbc, 0x95, 0xdd, 0x85, 0x4d, 0xb2, 0x53,
	0xa8, 0xdd, 0xf3, 0x73, 0xc4, 0x63, 0x22, 0x56, 0xd7, 0x86, 0x8e, 0xd9, 0x05, 0xb6, 0x76, 0x14,
	0xe9, 0x6d, 0x14, 0x8b, 0x50, 0x26, 0xbc, 0x4e, 0x2f, 0xff, 0x68, 0xb9, 0x68, 0xd6, 0x7a, 0xb9,
	0xb1, 0x03, 0x7b, 0xfd, 0xa0, 0x26, 0x3f, 0xce, 0x24, 0xec, 0x1a, 0x9e, 0x6c, 0xaa, 0x6d, 0x4c,
	0x4e, 0xc8, 0xe4, 0xe9, 0x72, 0xd1, 0x3c, 0xbc, 0x59, 0x15, 0x5d, 0xbb, 0x1c, 0xea, 0x07, 0xa9,
	0x84, 0xbd, 0x00, 0x10, 0x33, 0xa1, 0x30, 0xc4, 0x79, 0x22, 0xf8, 0x73, 0x37, 0x49, 0xca, 0xfc,
	0x38, 0x4f, 0x84, 0x7d, 0x6a, 0xb3, 0x49, 0xa4, 0x42, 0xa9, 0xf8, 0x0b, 0xfa, 0xcf, 0x28, 0xda,
	0xb0, 0xa7, 0xec, 0x6b, 0x22, 0x40, 0x67, 0xc8, 0x1b, 0x84, 0x10, 0xf1, 0x26, 0xc3, 0x76, 0x04,
	0xd5, 0xbe, 0xdb, 0x65, 0xf9, 0x96, 0x61, 0x37, 0x50, 0xf8, 0x39, 0xbe, 0xbb, 0xa5, 0xcd, 0x50,
	0x39, 0x3f, 0xf3, 0x1f, 0xb1, 0x04, 0x7d, 0xbb, 0x5f, 0xba, 0xa5, 0xe5, 0xa2, 0x49, 0x9b, 0x26,
	0x20, 0xa3, 0xf6, 0x9f, 0x1e, 0x1c, 0xac, 0x6b, 0xe4, 0xab, 0x4b, 0x43, 0x25, 0x52, 0x4a, 0x63,
	0x84, 0x52, 0x2b, 0xc3, 0xbd, 0xd6, 0xf6, 0x69, 0xe5, 0xfc, 0xfd, 0xa3, 0x6a, 0x3d, 0xb0, 0xf4,
	0x2f, 0x36, 0x7e, 0xd7, 0x0a, 0xd3, 0x79, 0x70, 0xbf, 0x42, 0xfd, 0x1b, 0xa8, 0x3d, 0x24, 0xb0,
	0x1a, 0x6c, 0x8f, 0xc5, 0x3c, 0x5f, 0x9f, 0xf6, 0xc8, 0x8e, 0x60, 0x67, 0x16, 0x4d, 0x32, 0x91,
	0xef, 0x4e, 0x17, 0x7c, 0xbd, 0xf5, 0xda, 0x3b, 0xff, 0x7d, 0x0b, 0xca, 0xfd, 0x55, 0x0f, 0xec,
	0x57, 0x28, 0xd8, 0x4d, 0xcc, 0x5e, 0x3f, 0xaa, 0xe3, 0x7b, 0xbb, 0xbc, 0xfe, 0xd5, 0x27, 0x28,
	0xf3, 0xd9, 0xfd, 0xe6, 0xc1, 0x6e, 0xde, 0x0a, 0x7b, 0xf3, 0x69, 0x23, 0x73, 0x3d, 0xbc, 0xfd,
	0x2f, 0xf3, 0xee, 0x5e, 0xfe, 0xb5, 0x6c, 0x78, 0x7f, 0x2f, 0x1b, 0xde, 0x3f, 0xcb, 0x86, 0xf7,
	0xd3, 0x97, 0x8f, 0xff, 0xbd, 0x7d, 0x33, 0x3b, 0x1b, 0x14, 0x69, 0x3d, 0x7f, 0xf1, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x89, 0x6f, 0xa5, 0x83, 0xaf, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ProcessorClient is the client API for Processor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProcessorClient interface {
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	Process(ctx context.Context, in *ProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error)
}

type processorClient struct {
	cc *grpc.ClientConn
}

func NewProcessorClient(cc *grpc.ClientConn) ProcessorClient {
	return &processorClient{cc}
}

func (c *processorClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, "/com.kentiklabs.ktranslate.processors.api.v1.Processor/Info", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processorClient) Process(ctx context.Context, in *ProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error) {
	out := new(ProcessResponse)
	err := c.cc.Invoke(ctx, "/com.kentiklabs.ktranslate.processors.api.v1.Processor/Process", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessorServer is the server API for Processor service.
type ProcessorServer interface {
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	Process(context.Context, *ProcessRequest) (*ProcessResponse, error)
}

// UnimplementedProcessorServer can be embedded to have forward compatible implementations.
type UnimplementedProcessorServer struct {
}

func (*UnimplementedProcessorServer) Info(ctx context.Context, req *InfoRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (*UnimplementedProcessorServer) Process(ctx context.Context, req *ProcessRequest) (*ProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Process not implemented")
}

func RegisterProcessorServer(s *grpc.Server, srv ProcessorServer) {
	s.RegisterService(&_Processor_serviceDesc, srv)
}

func _Processor_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.kentiklabs.ktranslate.processors.api.v1.Processor/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processor_Process_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessorServer).Process(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.kentiklabs.ktranslate.processors.api.v1.Processor/Process",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessorServer).Process(ctx, req.(*ProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Processor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.kentiklabs.ktranslate.processors.api.v1.Processor",
	HandlerType: (*ProcessorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _Processor_Info_Handler,
		},
		{
			MethodName: "Process",
			Handler:    _Processor_Process_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/kentik/ktranslate/pkg/processors/api/v1/processor.proto",
}

func (m *InfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JCHF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JCHF) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JCHF) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VlanOut != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.VlanOut))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.VlanIn != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.VlanIn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.EventType) > 0 {
		i -= len(m.EventType)
		copy(dAtA[i:], m.EventType)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.EventType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.OutputInterfaceIP) > 0 {
		i -= len(m.OutputInterfaceIP)
		copy(dAtA[i:], m.OutputInterfaceIP)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.OutputInterfaceIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.InputInterfaceIP) > 0 {
		i -= len(m.InputInterfaceIP)
		copy(dAtA[i:], m.InputInterfaceIP)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.InputInterfaceIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.OutputIntAlias) > 0 {
		i -= len(m.OutputIntAlias)
		copy(dAtA[i:], m.OutputIntAlias)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.OutputIntAlias)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.InputIntAlias) > 0 {
		i -= len(m.InputIntAlias)
		copy(dAtA[i:], m.InputIntAlias)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.InputIntAlias)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.OutputIntDesc) > 0 {
		i -= len(m.OutputIntDesc)
		copy(dAtA[i:], m.OutputIntDesc)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.OutputIntDesc)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.InputIntDesc) > 0 {
		i -= len(m.InputIntDesc)
		copy(dAtA[i:], m.InputIntDesc)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.InputIntDesc)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DstEthMac) > 0 {
		i -= len(m.DstEthMac)
		copy(dAtA[i:], m.DstEthMac)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DstEthMac)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.SrcEthMac) > 0 {
		i -= len(m.SrcEthMac)
		copy(dAtA[i:], m.SrcEthMac)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.SrcEthMac)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DstGeoCity) > 0 {
		i -= len(m.DstGeoCity)
		copy(dAtA[i:], m.DstGeoCity)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DstGeoCity)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.SrcGeoCity) > 0 {
		i -= len(m.SrcGeoCity)
		copy(dAtA[i:], m.SrcGeoCity)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.SrcGeoCity)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.DstGeoRegion) > 0 {
		i -= len(m.DstGeoRegion)
		copy(dAtA[i:], m.DstGeoRegion)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DstGeoRegion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SrcGeoRegion) > 0 {
		i -= len(m.SrcGeoRegion)
		copy(dAtA[i:], m.SrcGeoRegion)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.SrcGeoRegion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.OutPkts != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.OutPkts))
		i--
		dAtA[i] = 0x78
	}
	if m.OutBytes != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.OutBytes))
		i--
		dAtA[i] = 0x70
	}
	if m.InPkts != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.InPkts))
		i--
		dAtA[i] = 0x68
	}
	if m.InBytes != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.InBytes))
		i--
		dAtA[i] = 0x60
	}
	if len(m.SrcGeo) > 0 {
		i -= len(m.SrcGeo)
		copy(dAtA[i:], m.SrcGeo)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.SrcGeo)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SrcAs != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.SrcAs))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x42
	}
	if m.L4SrcPort != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.L4SrcPort))
		i--
		dAtA[i] = 0x38
	}
	if m.L4DstPort != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.L4DstPort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SrcAddr) > 0 {
		i -= len(m.SrcAddr)
		copy(dAtA[i:], m.SrcAddr)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.SrcAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DstAddr) > 0 {
		i -= len(m.DstAddr)
		copy(dAtA[i:], m.DstAddr)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DstAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DstGeo) > 0 {
		i -= len(m.DstGeo)
		copy(dAtA[i:], m.DstGeo)
		i = encodeVarintProcessor(dAtA, i, uint64(len(m.DstGeo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstAs != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.DstAs))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintProcessor(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JCHF != nil {
		{
			size, err := m.JCHF.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessor(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintProcessor(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessor(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintProcessor(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessor(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JCHF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovProcessor(uint64(m.Timestamp))
	}
	if m.DstAs != 0 {
		n += 1 + sovProcessor(uint64(m.DstAs))
	}
	l = len(m.DstGeo)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	l = len(m.DstAddr)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	l = len(m.SrcAddr)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	if m.L4DstPort != 0 {
		n += 1 + sovProcessor(uint64(m.L4DstPort))
	}
	if m.L4SrcPort != 0 {
		n += 1 + sovProcessor(uint64(m.L4SrcPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	if m.SrcAs != 0 {
		n += 1 + sovProcessor(uint64(m.SrcAs))
	}
	l = len(m.SrcGeo)
	if l > 0 {
		n += 1 + l + sovProcessor(uint64(l))
	}
	if m.InBytes != 0 {
		n += 1 + sovProcessor(uint64(m.InBytes))
	}
	if m.InPkts != 0 {
		n += 1 + sovProcessor(uint64(m.InPkts))
	}
	if m.OutBytes != 0 {
		n += 1 + sovProcessor(uint64(m.OutBytes))
	}
	if m.OutPkts != 0 {
		n += 1 + sovProcessor(uint64(m.OutPkts))
	}
	l = len(m.SrcGeoRegion)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.DstGeoRegion)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.SrcGeoCity)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.DstGeoCity)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.SrcEthMac)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.DstEthMac)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.InputIntDesc)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.OutputIntDesc)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.InputIntAlias)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.OutputIntAlias)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.InputInterfaceIP)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.OutputInterfaceIP)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	l = len(m.EventType)
	if l > 0 {
		n += 2 + l + sovProcessor(uint64(l))
	}
	if m.VlanIn != 0 {
		n += 2 + sovProcessor(uint64(m.VlanIn))
	}
	if m.VlanOut != 0 {
		n += 2 + sovProcessor(uint64(m.VlanOut))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JCHF != nil {
		l = m.JCHF.Size()
		n += 1 + l + sovProcessor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProcessor(uint64(len(k))) + 1 + len(v) + sovProcessor(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessor(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovProcessor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessor(x uint64) (n int) {
	return sovProcessor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JCHF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JCHF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JCHF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAs", wireType)
			}
			m.DstAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstAs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGeo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstGeo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DstPort", wireType)
			}
			m.L4DstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4DstPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4SrcPort", wireType)
			}
			m.L4SrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4SrcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAs", wireType)
			}
			m.SrcAs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcAs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGeo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcGeo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBytes", wireType)
			}
			m.InBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPkts", wireType)
			}
			m.InPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutBytes", wireType)
			}
			m.OutBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPkts", wireType)
			}
			m.OutPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGeoRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcGeoRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGeoRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstGeoRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcGeoCity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcGeoCity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstGeoCity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstGeoCity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcEthMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcEthMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstEthMac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstEthMac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputIntDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputIntDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputIntDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputIntDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputIntAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputIntAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputIntAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputIntAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputInterfaceIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputInterfaceIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputInterfaceIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputInterfaceIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanIn", wireType)
			}
			m.VlanIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanOut", wireType)
			}
			m.VlanOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JCHF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JCHF == nil {
				m.JCHF = &JCHF{}
			}
			if err := m.JCHF.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessor
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessor
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessor
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessor
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessor
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessor        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessor          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessor = fmt.Errorf("proto: unexpected end of group")
)
